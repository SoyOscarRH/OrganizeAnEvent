import { SimpleTagPropsT, CustomEventT } from '@rmwc/base';
import * as React from 'react';
declare type AnchorT = 'bottomEnd' | 'bottomLeft' | 'bottomRight' | 'bottomStart' | 'topEnd' | 'topLeft' | 'topRight' | 'topStart';
/****************************************************************
 * Menu
 ****************************************************************/
export declare type SelectedEventDetailT = {
    index: number;
    item: HTMLElement;
};
export declare type MenuPropsT = {
    /** Whether or not the Menu is open. */
    open?: boolean;
    /** Make the menu position fixed. */
    fixed?: boolean;
    /** Callback that when the menu is closed. */
    onClose?: (evt: CustomEventT<void>) => any;
    /** Callback that fires when a Menu item is selected. */
    onSelect?: (evt: CustomEventT<SelectedEventDetailT>) => any;
    /** Manually position the menu to one of the corners. */
    anchorCorner?: AnchorT;
} & SimpleTagPropsT;
export declare const MenuRoot: React.ComponentType<SimpleTagPropsT>;
export declare const MenuItems: React.ComponentType<SimpleTagPropsT>;
/** This is just the ListItem component exported from the Menu module for convenience. You can use `ListItem` or `SimpleListItem` components from the List section as long as you add `role="menuitem"` and `tabIndex="0"` to the components for accessibility. */
export declare class MenuItem extends React.Component<any> {
    static displayName: string;
    render(): JSX.Element;
}
declare const Menu_base: {
    new <P>(props: P & {
        tag?: string | React.ComponentClass<any, any> | React.StatelessComponent<any> | undefined;
        wrap?: boolean | undefined;
        elementRef?: any;
        theme?: string | string[] | undefined;
        apiRef?: (<S>(api: S) => S) | undefined;
    } & React.HTMLAttributes<any> & React.HTMLProps<any>): {
        foundation_: {
            [key: string]: any;
            adapter_: any;
            init: Function;
            destroy: Function;
        } | null;
        foundationRefs: {
            [name: string]: (ref: HTMLElement) => any;
        };
        root_: Element | Text | null;
        props: P & {
            tag?: string | React.ComponentClass<any, any> | React.StatelessComponent<any> | undefined;
            wrap?: boolean | undefined;
            elementRef?: any;
            theme?: string | string[] | undefined;
            apiRef?: (<S>(api: S) => S) | undefined;
        } & React.HTMLAttributes<any> & React.HTMLProps<any>;
        componentDidMount(): void;
        componentWillReceiveProps(nextProps: P & {
            tag?: string | React.ComponentClass<any, any> | React.StatelessComponent<any> | undefined;
            wrap?: boolean | undefined;
            elementRef?: any;
            theme?: string | string[] | undefined;
            apiRef?: (<S>(api: S) => S) | undefined;
        } & React.HTMLAttributes<any> & React.HTMLProps<any>): void;
        componentWillUnmount(): void;
        _safeSyncWithProps(props: Object): void;
        initFoundation(): void;
        destroyComponent(): void;
        syncWithProps(nextProps: Object): void;
        initialize(...args: any[]): void;
        initialSyncWithDOM(): void;
        destroy(): void; /** Opens the menu. */
        getDefaultFoundation(): {
            adapter_: {};
            init: () => void;
            destroy: () => void;
        };
        emit(evtType: string, evtData: Object, shouldBubble?: boolean, sync?: boolean): any;
        listen(evtType: string, handler: Function): void;
        unlisten(evtType: string, handler: Function): void;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<P & {
            tag?: string | React.ComponentClass<any, any> | React.StatelessComponent<any> | undefined;
            wrap?: boolean | undefined;
            elementRef?: any;
            theme?: string | string[] | undefined;
            apiRef?: (<S>(api: S) => S) | undefined;
        } & React.HTMLAttributes<any> & React.HTMLProps<any>>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callBack?: (() => void) | undefined): void;
        render(): React.ReactNode;
        state: Readonly<{}>;
        context: any;
        refs: {
            [key: string]: React.ReactInstance;
        };
    };
};
/** A menu component for displaying lists items. */
export declare class Menu extends Menu_base<MenuPropsT> {
    static displayName: string;
    open: boolean;
    setAnchorCorner: Function;
    menuSurface_: any;
    constructor(props: MenuPropsT);
    syncWithProps(nextProps: MenuPropsT): void;
    componentDidMount(): void;
    onCloseHandler_(evt: CustomEventT<void>): void;
    destroy(): void;
    render(): JSX.Element;
}
/****************************************************************
 * MenuSurface
 ****************************************************************/
export declare type MenuSurfacePropsT = {
    /** Opens the menu. */
    open?: boolean;
    /** Make the menu position fixed. */
    fixed?: boolean;
    /** Manually position the menu to one of the corners. */
    anchorCorner?: AnchorT;
    /** Callback for when the menu is opened. */
    onOpen?: (evt: CustomEventT<void>) => any;
    /** Callback for when the menu is closed. */
    onClose?: (evt: CustomEventT<void>) => any;
    /** Children to render. */
    children?: React.ReactNode;
} & SimpleTagPropsT;
export declare const MenuSurfaceRoot: React.ComponentType<SimpleTagPropsT>;
declare const MenuSurface_base: {
    new <P>(props: P & {
        tag?: string | React.ComponentClass<any, any> | React.StatelessComponent<any> | undefined;
        wrap?: boolean | undefined;
        elementRef?: any;
        theme?: string | string[] | undefined;
        apiRef?: (<S>(api: S) => S) | undefined;
    } & React.HTMLAttributes<any> & React.HTMLProps<any>): {
        foundation_: {
            [key: string]: any;
            adapter_: any;
            init: Function;
            destroy: Function;
        } | null;
        foundationRefs: {
            [name: string]: (ref: HTMLElement) => any;
        };
        root_: Element | Text | null;
        props: P & {
            tag?: string | React.ComponentClass<any, any> | React.StatelessComponent<any> | undefined;
            wrap?: boolean | undefined;
            elementRef?: any;
            theme?: string | string[] | undefined;
            apiRef?: (<S>(api: S) => S) | undefined;
        } & React.HTMLAttributes<any> & React.HTMLProps<any>;
        componentDidMount(): void;
        componentWillReceiveProps(nextProps: P & {
            tag?: string | React.ComponentClass<any, any> | React.StatelessComponent<any> | undefined;
            wrap?: boolean | undefined;
            elementRef?: any;
            theme?: string | string[] | undefined;
            apiRef?: (<S>(api: S) => S) | undefined;
        } & React.HTMLAttributes<any> & React.HTMLProps<any>): void;
        componentWillUnmount(): void;
        _safeSyncWithProps(props: Object): void;
        initFoundation(): void;
        destroyComponent(): void;
        syncWithProps(nextProps: Object): void;
        initialize(...args: any[]): void;
        initialSyncWithDOM(): void;
        destroy(): void; /** Opens the menu. */
        getDefaultFoundation(): {
            adapter_: {};
            init: () => void;
            destroy: () => void;
        };
        emit(evtType: string, evtData: Object, shouldBubble?: boolean, sync?: boolean): any;
        listen(evtType: string, handler: Function): void;
        unlisten(evtType: string, handler: Function): void;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<P & {
            tag?: string | React.ComponentClass<any, any> | React.StatelessComponent<any> | undefined;
            wrap?: boolean | undefined;
            elementRef?: any;
            theme?: string | string[] | undefined;
            apiRef?: (<S>(api: S) => S) | undefined;
        } & React.HTMLAttributes<any> & React.HTMLProps<any>>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callBack?: (() => void) | undefined): void;
        render(): React.ReactNode;
        state: Readonly<{}>;
        context: any;
        refs: {
            [key: string]: React.ReactInstance;
        };
    };
};
/** A generic menu component for displaying any type of content. */
export declare class MenuSurface extends MenuSurface_base<MenuSurfacePropsT> {
    open: boolean;
    foundation_: any;
    setAnchorCorner: Function;
    deregisterBodyClickListener_: Function;
    syncWithProps(nextProps: MenuSurfacePropsT): void;
    destroy(): void;
    render(): JSX.Element;
}
/****************************************************************
 * MenuSurfaceAnchor
 ****************************************************************/
/** A Menu Anchor. When using the anchorCorner prop of Menu, you must set MenuSurfaceAnchors css style position to absolute. */
export declare const MenuSurfaceAnchor: React.ComponentType<SimpleTagPropsT>;
/****************************************************************
 * Simple Menu
 ****************************************************************/
export declare type SimpleMenuPropsT = {
    /** An element that will open the menu when clicked  */
    handle: React.ReactElement<any>;
    /** By default, props spread to the Menu component. These will spread to the MenuSurfaceAnchor which is useful for things like overall positioning of the anchor.   */
    rootProps?: Object;
    /** Children to render */
    children?: React.ReactNode;
};
export declare type SimpleMenuFactoryPropsT = SimpleMenuPropsT & MenuPropsT & MenuSurfacePropsT;
export declare type SimpleMenuStateT = {
    open: boolean;
};
/**
 * A Simplified menu component that allows you to pass a handle element and will automatically control the open state and add a MenuSurfaceAnchor
 */
export declare const SimpleMenu: (props: SimpleMenuPropsT & {
    /** Whether or not the Menu is open. */
    open?: boolean | undefined;
    /** Make the menu position fixed. */
    fixed?: boolean | undefined;
    /** Callback that when the menu is closed. */
    onClose?: ((evt: CustomEventT<void>) => any) | undefined;
    /** Callback that fires when a Menu item is selected. */
    onSelect?: ((evt: CustomEventT<SelectedEventDetailT>) => any) | undefined;
    /** Manually position the menu to one of the corners. */
    anchorCorner?: "bottomEnd" | "bottomLeft" | "bottomRight" | "bottomStart" | "topEnd" | "topLeft" | "topRight" | "topStart" | undefined;
} & {
    tag?: string | React.ComponentClass<any, any> | React.StatelessComponent<any> | undefined;
    wrap?: boolean | undefined;
    elementRef?: any;
    theme?: string | string[] | undefined;
    apiRef?: (<S>(api: S) => S) | undefined;
} & React.HTMLAttributes<any> & React.HTMLProps<any>) => JSX.Element;
/**
 * The same as SimpleMenu, but a generic surface.
 */
export declare const SimpleMenuSurface: (props: SimpleMenuPropsT & {
    /** Opens the menu. */
    open?: boolean | undefined;
    /** Make the menu position fixed. */
    fixed?: boolean | undefined;
    /** Manually position the menu to one of the corners. */
    anchorCorner?: "bottomEnd" | "bottomLeft" | "bottomRight" | "bottomStart" | "topEnd" | "topLeft" | "topRight" | "topStart" | undefined;
    /** Callback for when the menu is opened. */
    onOpen?: ((evt: CustomEventT<void>) => any) | undefined;
    /** Callback for when the menu is closed. */
    onClose?: ((evt: CustomEventT<void>) => any) | undefined;
    /** Children to render. */
    children?: React.ReactNode;
} & {
    tag?: string | React.ComponentClass<any, any> | React.StatelessComponent<any> | undefined;
    wrap?: boolean | undefined;
    elementRef?: any;
    theme?: string | string[] | undefined;
    apiRef?: (<S>(api: S) => S) | undefined;
} & React.HTMLAttributes<any> & React.HTMLProps<any>) => JSX.Element;
export {};
